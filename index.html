<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D AR Wedding Navigation</title>
    
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet">
    
    <style>
        /* UI Reset */
        body { margin: 0; overflow: hidden; background: black; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; }
        
        /* 1. The Camera Feed */
        #camera-feed {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: -2;
        }

        /* 2. The 3D AR Layer */
        #ar-canvas {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: -1; pointer-events: none;
        }

        /* 3. HUD (Distance & Instruction) */
        #hud {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7); 
            padding: 12px 24px; 
            border-radius: 50px;
            border: 3px solid #00ff00; /* Start Green */
            color: #fff; font-weight: 800;
            font-size: 18px; z-index: 10; text-transform: uppercase;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); 
            white-space: nowrap;
            transition: border-color 0.3s, color 0.3s;
        }

        /* 4. Mini Map */
        #mini-map {
            position: fixed; bottom: 30px; right: 20px;
            width: 140px; height: 140px; 
            border-radius: 20px; border: 4px solid white; 
            background: #222; z-index: 10;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            overflow: hidden;
        }

        /* 5. Start Button */
        #start-btn {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            padding: 20px 50px; font-size: 20px; background: #00e5ff; color: #000;
            border: none; border-radius: 50px; font-weight: 900; z-index: 50; cursor: pointer;
            box-shadow: 0 0 25px #00e5ff;
        }
    </style>
</head>
<body>

    <video id="camera-feed" autoplay playsinline muted></video>

    <canvas id="ar-canvas"></canvas>

    <div id="hud">Waiting for Start...</div>
    <div id="mini-map"></div>
    <button id="start-btn" onclick="startAR()">ENTER AR MODE</button>

    <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ================= CONFIGURATION =================
        // ðŸ”´ðŸ”´ PASTE YOUR TOKEN BELOW ðŸ”´ðŸ”´
        const MAPBOX_TOKEN = 'pk.eyJ1IjoiaGVtYW50aDg1MDMiLCJhIjoiY21rNzV5c2w2MHlqeTNncjI5bjkyeWJwaiJ9.NnunzAB_24Ntn83H5hRcyQ'; 
        
        // DESTINATION: [Longitude, Latitude]
        const DESTINATION = [79.1559, 12.9692]; // VIT Vellore

        // ================= VARIABLES =================
        let map, scene, camera, renderer, arrowMesh;
        let shaftMesh, headMesh; 
        let steps = [], currentStepIndex = 0;
        let deviceHeading = 0; 
        let targetBearing = 0; 
        let currentDist = 999; 
        let isRunning = false;

        // ================= STARTUP =================
        async function startAR() {
            if(MAPBOX_TOKEN.includes('YOUR_MAPBOX')) {
                alert("âš ï¸ Error: You forgot to paste your Mapbox Token inside the code!"); 
                return;
            }
            document.getElementById("start-btn").style.display = "none";
            document.getElementById("hud").innerText = "Aligning Sensors...";
            
            // 1. Camera Access
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment" } 
                });
                document.getElementById("camera-feed").srcObject = stream;
            } catch(e) { 
                console.error(e);
                alert("Camera Access Denied. App needs camera to work.");
            }

            // 2. Initialize Systems
            initThreeJS();
            initMap();
            requestSensors();
            
            // 3. Start Animation
            isRunning = true;
            animate(); 
        }

        // ================= 3D ENGINE =================
        function initThreeJS() {
            const canvas = document.getElementById('ar-canvas');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // --- BUILD ARROW ---
            arrowMesh = new THREE.Group();

            // Shaft (Green initially)
            const geometryShaft = new THREE.CylinderGeometry(0.2, 0.2, 2, 32);
            const materialShaft = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); 
            shaftMesh = new THREE.Mesh(geometryShaft, materialShaft);
            shaftMesh.rotation.x = Math.PI / 2;
            shaftMesh.position.z = 1;

            // Head (Green initially)
            const geometryHead = new THREE.ConeGeometry(0.6, 1.2, 32);
            const materialHead = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); 
            headMesh = new THREE.Mesh(geometryHead, materialHead);
            headMesh.rotation.x = Math.PI / 2;
            headMesh.position.z = -0.5;

            arrowMesh.add(shaftMesh);
            arrowMesh.add(headMesh);

            // Position: On ground (-1.5), 4m ahead (-4)
            arrowMesh.position.set(0, -1.5, -4); 
            scene.add(arrowMesh);
            scene.add(new THREE.AmbientLight(0xffffff, 1));
        }

        // ================= ANIMATION LOOP =================
        function animate() {
            requestAnimationFrame(animate);

            if(isRunning && arrowMesh) {
                let desiredRotationY = 0;

                // --- CRUISE MODE vs TURN MODE LOGIC ---
                // > 20m: Cruise Mode (Green, Point Straight)
                // < 20m: Turn Mode (Cyan, Point to Real World Coordinate)
                
                if (currentDist > 20) {
                    // GO STRAIGHT (HUD Mode)
                    desiredRotationY = 0; 
                    
                    // Visuals: Green
                    if(shaftMesh) shaftMesh.material.color.setHex(0x00ff00); 
                    if(headMesh) headMesh.material.color.setHex(0x00ff00);
                } 
                else {
                    // TURN NOW (Real World Lock)
                    // Calculate relative angle: Target - Phone Heading
                    let bearingDiff = targetBearing - deviceHeading;
                    desiredRotationY = -bearingDiff * (Math.PI / 180); // Invert for Three.js

                    // Visuals: Cyan
                    if(shaftMesh) shaftMesh.material.color.setHex(0x00e5ff); 
                    if(headMesh) headMesh.material.color.setHex(0x00e5ff);
                }

                // Smooth Rotation (Lerp with wrap-around fix)
                let currentY = arrowMesh.rotation.y;
                let diff = desiredRotationY - currentY;
                
                // Fix the 360-degree jump (so arrow doesn't spin the long way round)
                while (diff > Math.PI) diff -= Math.PI * 2;
                while (diff < -Math.PI) diff += Math.PI * 2;
                
                arrowMesh.rotation.y += diff * 0.1; // 0.1 = Smoothing factor

                // Bobbing Effect
                arrowMesh.position.y = -1.5 + Math.sin(Date.now() * 0.003) * 0.1;
                
                renderer.render(scene, camera);
            }
        }

        // ================= SENSORS =================
        function requestSensors() {
            // iOS Permission Check
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission().then(r => {
                    if (r === 'granted') window.addEventListener('deviceorientation', handleOrientation);
                });
            } else {
                window.addEventListener('deviceorientation', handleOrientation);
            }

            // GPS Tracking
            if(navigator.geolocation) {
                navigator.geolocation.watchPosition(handleGPS, 
                    (err) => console.error("GPS Error:", err), 
                    { enableHighAccuracy: true, maximumAge: 0 }
                );
            }
        }

        function handleOrientation(e) {
            // Get Compass Heading
            let heading = e.webkitCompassHeading || (e.alpha ? 360 - e.alpha : 0);
            deviceHeading = heading;
        }

        function handleGPS(pos) {
            const lat = pos.coords.latitude;
            const lng = pos.coords.longitude;
            
            // 1. Initial Route Fetch
            if (steps.length === 0) getRoute(lat, lng);

            // 2. Update Map Marker
            if(map && window.userMarker) {
                window.userMarker.setLngLat([lng, lat]);
                map.flyTo({ center: [lng, lat], zoom: 17 });
            }

            // 3. Navigation Logic
            if (steps.length > 0 && currentStepIndex < steps.length) {
                const target = steps[currentStepIndex].maneuver.location; 
                
                // Update Global Distance
                currentDist = getDistance(lat, lng, target[1], target[0]);
                
                // Update HUD Text & Color
                const hud = document.getElementById("hud");
                const instr = steps[currentStepIndex].maneuver.instruction;
                hud.innerText = `${instr} (${Math.round(currentDist)}m)`;
                
                if(currentDist > 20) {
                    hud.style.borderColor = "#00ff00"; // Green Border
                    hud.style.color = "#00ff00";
                } else {
                    hud.style.borderColor = "#00e5ff"; // Cyan Border
                    hud.style.color = "#00e5ff";
                }

                // Update Target Bearing (Used only in Turn Mode)
                targetBearing = getBearing(lat, lng, target[1], target[0]);

                // Switch to Next Turn if close
                if (currentDist < 20 && currentStepIndex < steps.length - 1) {
                    currentStepIndex++;
                    // Note: currentDist will jump to high number next cycle, arrow turns Green.
                }
            }
        }

        // ================= HELPERS =================
        function initMap() {
            mapboxgl.accessToken = MAPBOX_TOKEN;
            map = new mapboxgl.Map({
                container: 'mini-map', style: 'mapbox://styles/mapbox/dark-v11',
                center: DESTINATION, zoom: 16, attributionControl: false
            });
            const el = document.createElement('div');
            el.className = 'marker'; el.style.backgroundColor = '#00ff00';
            el.style.width = '15px'; el.style.height = '15px';
            el.style.borderRadius = '50%'; el.style.border = '2px solid white';
            window.userMarker = new mapboxgl.Marker(el).setLngLat(DESTINATION).addTo(map);
            new mapboxgl.Marker({ color: 'red' }).setLngLat(DESTINATION).addTo(map);
        }

        async function getRoute(lat, lng) {
            const url = `https://api.mapbox.com/directions/v5/mapbox/walking/${lng},${lat};${DESTINATION[0]},${DESTINATION[1]}?steps=true&geometries=geojson&access_token=${MAPBOX_TOKEN}`;
            try {
                const res = await fetch(url);
                const data = await res.json();
                if(data.routes && data.routes.length > 0) {
                    steps = data.routes[0].legs[0].steps;
                    if(steps.length > 1) steps.shift(); // Remove "Depart"
                    
                    // Draw Green Path on Map
                    const geojson = data.routes[0].geometry;
                    map.on('load', () => {
                        map.addLayer({
                            id: 'route', type: 'line',
                            source: { type: 'geojson', data: { type: 'Feature', geometry: geojson } },
                            layout: { 'line-join': 'round', 'line-cap': 'round' },
                            paint: { 'line-color': '#00ff00', 'line-width': 4 }
                        });
                    });
                }
            } catch(e) { console.error(e); }
        }

        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const dLat = (lat2-lat1)*Math.PI/180;
            const dLon = (lon2-lon1)*Math.PI/180;
            const a = Math.sin(dLat/2)**2 + Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
            return R*2*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function getBearing(lat1, lon1, lat2, lon2) {
            const dLon = (lon2-lon1)*Math.PI/180;
            const y = Math.sin(dLon)*Math.cos(lat2*Math.PI/180);
            const x = Math.cos(lat1*Math.PI/180)*Math.sin(lat2*Math.PI/180) - Math.sin(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.cos(dLon);
            return (Math.atan2(y, x)*180/Math.PI + 360)%360;
        }

        // Handle Resize
        window.addEventListener('resize', () => {
            if(camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>
